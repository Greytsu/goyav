package spotify

import (
	"context"
	"golang.org/x/oauth2"
	"os"

	"github.com/rs/zerolog/log"
	"github.com/zmb3/spotify/v2"
	spotifyAuth "github.com/zmb3/spotify/v2/auth"

	"goyav/artist"
	"goyav/goyavUser"
	"goyav/track"
)

type Service struct {
	auth *spotifyAuth.Authenticator
}

func NewService(auth *spotifyAuth.Authenticator) *Service {
	return &Service{auth: auth}
}

// User
func (s *Service) CheckUser(tok *oauth2.Token) bool {
	// new spotify client
	client := spotify.New(s.auth.Client(context.Background(), tok))

	// retrieve current user info
	user, err := client.CurrentUser(context.Background())
	if err != nil {
		log.Info().Err(err).Msg("Error while fetching for current goyavUser")
		return false
	}
	if user.ID == "" {
		return false
	}
	return true
}

func (s *Service) GetCurrentUser(tok *oauth2.Token) (goyavUser.User, error) {
	// new spotify client
	client := spotify.New(s.auth.Client(context.Background(), tok))

	// retrieve current user info
	user, err := client.CurrentUser(context.Background())
	if err != nil {
		log.Info().Err(err).Msg("Error while fetching for current goyavUser")
		return goyavUser.User{}, err
	}
	goyavCurrentUser := goyavUser.MapSpotifyUserToGoyavUser(user)
	return goyavCurrentUser, nil
}

func (s *Service) GetCurrentUserTopArtists(tok *oauth2.Token) ([]artist.Artist, error) {
	// new spotify client
	client := spotify.New(s.auth.Client(context.Background(), tok))

	spotifyArtists, err := client.CurrentUsersTopArtists(context.Background())
	if err != nil {
		log.Info().Err(err).Msg("Error while fetching for current goyavUser top artists")
		return []artist.Artist{}, err
	}

	goyavArtists := artist.MapSpotifyArtistsToGoyavArtists(spotifyArtists.Artists)

	return goyavArtists, nil
}

func (s *Service) GetCurrentUserTopTracks(tok *oauth2.Token) (*spotify.FullTrackPage, error) {
	// new spotify client
	client := spotify.New(s.auth.Client(context.Background(), tok))

	tracks, err := client.CurrentUsersTopTracks(context.Background(), spotify.Timerange(spotify.ShortTermRange))
	if err != nil {
		log.Info().Err(err).Msg("Error while fetching for current goyavUser top tracks")
		return &spotify.FullTrackPage{}, err
	}

	return tracks, nil
}

// Recommendations
func (s *Service) GetRecommendations(tok *oauth2.Token, recommendationRequest *RecommendationRequest) ([]track.Track, error) {

	// check recommendationRequest
	if !CheckRecommendationRequest(recommendationRequest) {
		return nil, InvalidRecommendationRequestError
	}

	// new spotify client
	client := spotify.New(s.auth.Client(context.Background(), tok))

	var seeds spotify.Seeds
	var err error

	if recommendationRequest.Type == Track {
		seeds, err = getUserTrackSeeds(client, recommendationRequest.Timerange)
		if err != nil {
			return nil, err
		}
	}

	recommendedTracks, err := getRecommendations(context.Background(), client, seeds, recommendationRequest.Amount)
	if err != nil {
		return nil, err
	}

	return track.MapSpotifySimpleTracksToGoyavTracks(recommendedTracks.Tracks), nil
}

func getRecommendations(ctx context.Context, client *spotify.Client, seeds spotify.Seeds, amount int) (*spotify.Recommendations, error) {
	trackAttributes := spotify.NewTrackAttributes()
	trackAttributes.MinDuration(1000)

	return client.GetRecommendations(ctx, seeds, trackAttributes, spotify.Limit(amount))
}

func getUserTrackSeeds(client *spotify.Client, timerange spotify.Range) (spotify.Seeds, error) {
	// get user top tracks
	spotifyTracks, err := client.CurrentUsersTopTracks(context.Background(), spotify.Timerange(timerange), spotify.Limit(5))
	if err != nil {
		log.Info().Err(err).Msg("Error while fetching for current goyavUser top tracks")
		return spotify.Seeds{}, err
	}
	goyavTracks := track.MapSpotifyTracksToGoyavTracks(spotifyTracks.Tracks)

	// iterate by chunk since only 5 seeds can be used at a time
	seeds := spotify.Seeds{
		Artists: []spotify.ID{},
		Tracks:  track.MapToTrackSeeds(goyavTracks),
		Genres:  []string{},
	}

	return seeds, nil
}

// Playlists
func (s *Service) CreateSpotifyPlayList(tok *oauth2.Token, userID, playlistName string) (string, error) {
	client := spotify.New(s.auth.Client(context.Background(), tok))

	// Open the image
	image, err := os.Open("assets/goyav.png")
	if err != nil {
		log.Info().Err(err).Msg("error while opening image")
		return "", err
	}
	defer image.Close()

	// Create playlist
	playlist, err := client.CreatePlaylistForUser(context.Background(), userID, playlistName, "Playlist generated by goyav", true, false)
	if err != nil {
		log.Info().Err(err).Msg("error while creating playlist")
		return "", err
	}

	// Set a cover image for the playlist
	err = client.SetPlaylistImage(context.Background(), playlist.ID, image)
	if err != nil {
		log.Info().Err(err).Msg("error while setting playlist image")
		return "", err
	}

	return playlist.ID.String(), nil
}

func (s *Service) UpdatePlaylistTracks(ctx context.Context, tok *oauth2.Token, playlistID spotify.ID, tracks map[string]track.Track) error {
	client := spotify.New(s.auth.Client(context.Background(), tok))

	var trackIDs []spotify.ID
	trackIDs = MapTracksToSpotifyIDs(tracks)

	return client.ReplacePlaylistTracks(ctx, playlistID, trackIDs...)
}
